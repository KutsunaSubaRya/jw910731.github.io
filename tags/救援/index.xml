<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>救援 on jw910731's Blog</title><link>https://blog.jw910731.wtf/tags/%E6%95%91%E6%8F%B4/</link><description>Recent content in 救援 on jw910731's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 11 Dec 2020 11:48:09 +0800</lastBuildDate><atom:link href="https://blog.jw910731.wtf/tags/%E6%95%91%E6%8F%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>毒L紀 程設一[4] HW5心得 - Sanitizer啊 哪次不Sanitize</title><link>https://blog.jw910731.wtf/course/comp-prog-i-5/</link><pubDate>Fri, 11 Dec 2020 11:48:09 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-5/</guid><description>前言 這次的作業很歡樂的跟陣列有關，但眾所週知週知， C 語言的陣列若超界存取只會導致未定義行為，而沒有語言層的邊界檢查，這在撰寫複雜的邏輯時可能會難以追縱問題的來源，今天來安利個神兵利器。
Sanitizer 消毒劑 (X -fsanitize=undefined 未定義行為消毒劑，他可以幫你抓出各種未定義行為，包含無窮遞迴、 NULL Pointer Dereference 、陣列超界存取等⋯⋯祝你除百毒 ( ?
-fsanitize=leak 幫你抓記憶體洩漏，功能我覺得跟 Valgrind 不相上下，而且可以即時抓到記憶體洩漏，更加方便 ！
缺點是要 link -lusan 函數庫！
-fsanitize=address 這個可以幫你抓到不合法的記憶體存取 ( 也包含陣列存取超界 ) ，不過更為強大！</description></item><item><title>我所知道的物件導向 [2] 繼承</title><link>https://blog.jw910731.wtf/blog/oop-2/</link><pubDate>Wed, 09 Dec 2020 21:22:25 +0800</pubDate><guid>https://blog.jw910731.wtf/blog/oop-2/</guid><description>Chap1.1 專有名詞複習 為了後續好解釋，我們再複習一下專有名詞吧
類別 ( Class ) : 概念上是一種事物的種類，也可被想成是物件的藍圖，程式觀點上是多個變數的綁定描述
屬性 ( Properties ) : 就是一個 Class 所擁有的不同「屬性」，比如貓有花色、年齡等資訊，都屬於屬性的範疇！
物件 ( Object ) / 實例 ( Instance ) : 概念上就是真的活生生的一隻貓，而不是在你腦中對貓這種動物的認知；程式觀點上是真正在記憶體裡面的一組被綁定的數據！
方法 ( Method ) : 概念上是一種東西有哪些可以執行的行為，比如貓可以吃飯；程式觀點上很接近一個屬於一個 Class 的函數！</description></item><item><title>我所知道的物件導向 [1] C++與Java為什麼交不到女朋友？</title><link>https://blog.jw910731.wtf/blog/oop-1/</link><pubDate>Wed, 09 Dec 2020 01:21:53 +0800</pubDate><guid>https://blog.jw910731.wtf/blog/oop-1/</guid><description>緣起與開頭 如同這篇文章唯一的 tag 所透露，事情就是如此。我也想順便記錄我對於物件導向這麼多年(也才三年好嗎)一直更迭不斷的不同思維與觀點的變化與統整！
格式與用詞方式說明 本文會盡量以中文書寫，但遇到難以用中文辨別的詞，第一次會以中文附帶英文的方式出現，之後則都出現英文的版本！
如果有誤請幫我留言區留言或開個 issue 嘴我，感謝路過大神給予想法喔 &amp;gt;.&amp;lt;
Chap1 物件 物件導向乃以「物件」為中心的語言撰寫思維，透過將多個變數綁定為一個整體看待稱為物件 ( Object ) ，並視為不可分割的整體做操作，就是為物件導向。
從生活中的例子來說，物件導向中的類別 ( Class ) 就是我們對ㄧ「種」東西該有哪些屬性的描述，而物件 ( Object ) 則是活生生的那種東西。比如說，一隻貓，可能有性別、花色、年齡、是否結紮等⋯⋯屬性，每隻貓所擁有的屬性是相同，但每隻貓的狀態 ( 也就是這些屬性的值 ) 卻可能不同。也就是說，每隻貓貓雖然都有花色、年齡等這些屬性，卻不一定有相同的花色、年齡！這也就是 Class 與 Object 的區別！</description></item><item><title>毒L紀 程設一[4] HW4心得 - 遞迴模擬器</title><link>https://blog.jw910731.wtf/course/comp-prog-i-4/</link><pubDate>Sat, 28 Nov 2020 17:54:13 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-4/</guid><description>終於出現值得講的作業了呢！這次的要求是不以遞迴的方式實現河內塔
以迴圈實作遞迴 遞迴模擬器 沒錯，你的電腦其實是用類似迴圈的想法在執行階段實作遞迴的 ( 更正確而言是以循序執行的方式搭配資料結構實現遞迴的 ) ，所以你也可以實作一樣的資料結構，變可以以循序執行的方法實現遞迴了！
那個傳說中的資料結構就是 &amp;ldquo;Stack&amp;rdquo;，大概就是&amp;hellip;.
這麼簡單 ( X
具體而言就是：
當函數被呼叫時，所有的參數與區域變數都會存進 Stack 裡面 函數開始執行&amp;hellip; 此時如果又發生了函數呼叫 ( 不論被呼叫的是自己還是別人 ) ，區域變數繼續往 Stack 上面疊 當函數結束時，會將剛剛存進來的參數與區域變數都 Pop 掉 也就是說，只要用陣列實作一個 Stack 就好了！</description></item><item><title>毒L紀 程設一[3] HW1心得 - MultiTarget Makefile</title><link>https://blog.jw910731.wtf/course/comp-prog-i-3/</link><pubDate>Thu, 01 Oct 2020 15:45:12 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-3/</guid><description>Multi-target Makefile 好吧，我總算要面對這個可怕的事情了。 如果今天一個Makefile要生成多個目標，我應該怎麼辦QwQ
後來我找了一些資料後調配了這個Makefile
CC=gcc CFLAGS=-Wall -Wextra -std=c11 -O2 TARGETS=hw0101 hw0102 hw0103 hw0105 .PHONY: all all: $(TARGETS) .SECONDEXPANSION: $(TARGETS): %: $$*.o %.o: $@.c clean: rm -rf $(TARGETS) $(addsuffix .o,$(TARGETS)) 把TARGETS變數改成想編譯的執行檔檔名(們)，他就會去找同名的.</description></item><item><title>毒L紀 程設一[2] 建構工具</title><link>https://blog.jw910731.wtf/course/comp-prog-i-2/</link><pubDate>Wed, 23 Sep 2020 20:58:19 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-2/</guid><description>Make Intro Make指令會在執行時的word dir底下尋找Makefile這個檔案， 依照裡面的指示編譯你的程式，所以正確編寫Makefile就變成了建立建構系統時的一件重要的事情。
一個最簡單的Makefile大概如下
.PHONY: gcc -o main main.c 但我個人覺得之後檔案變多，還想加各種編譯參數加入後會變得很難調教，在下面給個我個人覺得很棒的Makefile範例。
安利時間 make是Linux系統上常見的建構工具，有著強大的功能。這邊展示我個人調教的Makefile
CC=gcc CFLAGS=-Wall -Wextra -O2 -std=c11 P=main OBJECTS=main.o $(P): $(OBJECTS) clean: rm $(OBJECTS) $(P) 其中要記得把OBJECTS變數設成自己原始檔(source)的名稱(請將副檔名改成.o)，若有多個檔案請以空格隔開，這樣在make執行時就會一併幫你組建好了。CFLAGS可以自己調成自己喜歡的編譯器參數，不管是享受-O3毒瘤的超爽加速還是想請編譯器別噴那麼多Warning都可以。
這個Makefile很短，且有很高的適應性，在期中期末即使遇到雞掰的要求也能優雅的組建。其中的編譯指令已經以make系統的預設建構指令隱含在裡面了，LDFLAG也因不需要link其他的Library而省略了。
詳細的Makefile設定方法可以看〈21世紀的C語言〉這本書，上面的Makefile也是在閱讀此書後寫的，書中講述了很多現代C語言在實戰中可以運用的技巧與如何優雅使用C語言，強烈推薦未來想繼續使用C語言的人入手！</description></item><item><title>毒L紀 程設一[1] Hello World與如何編譯</title><link>https://blog.jw910731.wtf/course/comp-prog-i-1/</link><pubDate>Fri, 18 Sep 2020 15:39:55 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-1/</guid><description>Programming 上課範例程式 #include &amp;lt;stdio.h&amp;gt;int main(){ printf(&amp;#34;Hello World!\n&amp;#34;); return 0; } main是C語言定義的Entry Point，程式執行後會呼叫main。
printf是格式化輸出的函數，型別為int printf ( const char * format, ... )，也就是說輸入一個「格式化字串」(型別為內容為常數的字元陣列(也是指標))，以及多個格式化字串所需的參數，輸出格式化字串格式化後的結果到標準輸出流。格式化字串的格式以連結為例！
return 0;事實上是main函數回傳給系統的Exit Code，可以代表程式結束的狀況是正常還是異常，以Linux而言0是正常退出。
毒瘤程式 #include &amp;lt;unistd.</description></item><item><title>毒L紀 程設一[0] 基本Linux開發環境設置</title><link>https://blog.jw910731.wtf/course/comp-prog-i-0/</link><pubDate>Wed, 16 Sep 2020 22:55:30 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-0/</guid><description>垃圾話 毒L紀 = 毒瘤+Linux紀
意指我以毒瘤的稱號讚嘆這個老師足夠狂，敢搬這麼毒瘤的東西出來給大家吸
總之這個系列不定期推出
會放點你可能必須知道的東西，也會放些不建議你抄也不太健康的東西
如何判斷不太健康，就是你感覺看不懂，貼進Google也查不太到正常的解釋，就是不健康
總之什麼都有什麼都不奇怪
設置Linux環境 Virtual Machine 你的選擇有
大陸正版的VMware 免費難用的Virtual box 自由選擇 如何安裝請相信Google小姐的力量 WSL 2 真的很香，究竟更新到2版後有什麼差請見
但總之建議不要用WSL 1惹L紀森77，而且那很毒瘤。
安裝教學可以Google也可以看
總之這傢伙可以給你一個Linux的Command Prompt(命令列)，而且你不需要手動分配固定大小的記憶體給他，他會自己想辦法，網路也互通，檔案可以從/mnt底下看到你的C槽D槽，但不太建議你把平常Linux的檔案放在Windows的檔案目錄下，不然存取檔案的效能可能會GG
Repl.it 這個網站提供Online Editor與Linux Container(可以想成一個人一個隔離的指令列環境)，可以提供輕量化的Linux開發環境，如果只想寫作業不想搞Linux我個人非常推薦。學生可以去註冊Github Student Pack，可以有一年免費Premium的功能！(這不是業配，相信我&amp;gt;.</description></item></channel></rss>