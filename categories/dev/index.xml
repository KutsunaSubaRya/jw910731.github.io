<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dev on jw910731's Blog</title><link>https://blog.jw910731.wtf/categories/dev/</link><description>Recent content in dev on jw910731's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 28 Nov 2020 17:54:13 +0800</lastBuildDate><atom:link href="https://blog.jw910731.wtf/categories/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>毒L紀 程設一[4] HW4心得 - 遞迴模擬器</title><link>https://blog.jw910731.wtf/course/comp-prog-i-4/</link><pubDate>Sat, 28 Nov 2020 17:54:13 +0800</pubDate><guid>https://blog.jw910731.wtf/course/comp-prog-i-4/</guid><description>終於出現值得講的作業了呢！這次的要求是不以遞迴的方式實現河內塔
以迴圈實作遞迴 遞迴模擬器 沒錯，你的電腦其實是用類似迴圈的想法在執行階段實作遞迴的 ( 更正確而言是以循序執行的方式搭配資料結構實現遞迴的 ) ，所以你也可以實作一樣的資料結構，變可以以循序執行的方法實現遞迴了！
那個傳說中的資料結構就是 &amp;ldquo;Stack&amp;rdquo;，大概就是&amp;hellip;.
這麼簡單 ( X
具體而言就是：
當函數被呼叫時，所有的參數與區域變數都會存進 Stack 裡面 函數開始執行&amp;hellip; 此時如果又發生了函數呼叫 ( 不論被呼叫的是自己還是別人 ) ，區域變數繼續往 Stack 上面疊 當函數結束時，會將剛剛存進來的參數與區域變數都 Pop 掉 也就是說，只要用陣列實作一個 Stack 就好了！</description></item></channel></rss>